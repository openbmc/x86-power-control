{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6962e54c_c42214a9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-05-10T22:14:22Z",
      "side": 1,
      "message": "What does any of this mean?  There are no dbus \"GPIOs\".  The interfaces are required to be well-formed interfaces like xyz.openbmc_project.Chassis.Control.Power, which have a clear meaning.  There is no such thing as \"polarity\" because these aren\u0027t GPIOs.",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e55fc844_4a4bf336",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-05-11T00:39:18Z",
      "side": 1,
      "message": "Well, yes, but...\n\nx86-power-control has had support for some time for reading inputs from dbus (since commit 7012051a49 was marged in July 2021).  I don\u0027t know the particulars of what motivated that (some platform specifics of tiogapass and yosemitev2 I guess?) or what (if any) discussion at the time there was of the appropriateness of that and what alternatives there might have been.\n\nI would agree that polarity on a dbus property is a fairly nonsensical concept in general, since if we take the position that the properties this is being used for are in fact some higher-level, more abstract representation of the information a raw GPIO would provide, presenting that information on dbus in an \"active-low\" way would be kind of silly.\n\nHowever, upon looking at the existing code and existing configs I could find in openbmc/openbmc, `meta-hpe/meta-rl300-g11/recipes-x86/x86-power-control/x86-power-control/power-config-host0.json` gets its `PowerButton` signal via dbus, and the code implementing the handler for that currently hard-codes it to active-low (though see also https://gerrit.openbmc.org/c/openbmc/x86-power-control/+/71283 for a somewhat related patch), so it does appear that some existing platforms do in fact have \"active-low\" dbus inputs anyway.\n\nGiven the existence of the functionality, I for one was looking at using it on a platform that doesn\u0027t have a (working) `POST_COMPLETE` GPIO and instead has the host notify the BMC of POST state transitions via OEM IPMI commands over KCS.  So I suppose the obvious alternative there would be to make the `xyz.openbmc_project.State.OperatingSystem.Status` handling in x86-power-control optional and move it to ipmid on that platform?  Though it seems like a bit of an odd fit there, TBH...maybe there\u0027s some better possibility I haven\u0027t considered.",
      "parentUuid": "6962e54c_c42214a9",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f2a4493_7fd55fce",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-05-13T17:00:47Z",
      "side": 1,
      "message": "\u003e However, upon looking at the existing code and existing configs I could find in openbmc/openbmc, meta-hpe/meta-rl300-g11/recipes-x86/x86-power-control/x86-power-control/power-config-host0.json gets its PowerButton signal via dbus...\n\nThis is 100% a violation of our anti-patterns though and doesn\u0027t actually work with any real code in upstream:\n\n```\n    {\n        \"Name\" : \"PowerButton\",\n        \"DbusName\" : \"xyz.openbmc_project.Chassis.Gpios\",\n        \"Path\" : \"/xyz/openbmc_project/chassis/gpios\",\n        \"Interface\" : \"xyz.openbmc_project.Chassis.Gpios\",\n        \"Property\" : \"PButton\",\n        \"Type\" : \"DBUS\"\n    },\n```\n\nI can\u0027t help when machine owners violate project practices if we\u0027ve made them OWNERs, but we can\u0027t use that as an example of \"existing code\".\n\nHPE seems to have a bunch of implementations using some downstream `xyz.openbmc_project.Chassis.Gpios` service.",
      "parentUuid": "e55fc844_4a4bf336",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e309647e_5f4fe9a6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-05-14T03:30:41Z",
      "side": 1,
      "message": "Ack -- though in fairness, aside from avoiding the active-low oddity is this from meta-facebook appreciably different?\n\n```\n    {\n        \"Name\" : \"PowerOk\",\n        \"DbusName\" : \"xyz.openbmc_project.IpmbSensor\",\n        \"Path\" : \"/xyz/openbmc_project/gpio/ipmbGpioState/1_CPU_Good\",\n        \"Interface\" : \"xyz.openbmc_project.Chassis.Control.Power\",\n        \"Property\" : \"PGood\",\n        \"Type\" : \"DBUS\"\n    }\n```\n\n(That file and its siblings are the only hits I get on `ipmbGpioState` on both grok.openbmc.org and a github openbmc org search, FWIW.)\n\nStepping back a bit though -- would you say the x86-power-control dbus-input feature entirely inappropriate then?  Does there (or could there hypothetically) exist a use of it that isn\u0027t an anti-pattern violation?\n\n(And at the moment I\u0027m also still a bit stumped as to how to go about supporting a system that communicates POST state via IPMI/KCS instead of a GPIO.)",
      "parentUuid": "2f2a4493_7fd55fce",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6dedbba_22408205",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-05-15T19:21:20Z",
      "side": 1,
      "message": "\u003e Stepping back a bit though -- would you say the x86-power-control dbus-input feature entirely inappropriate then? Does there (or could there hypothetically) exist a use of it that isn\u0027t an anti-pattern violation?\n\nConceptually, it should not be inappropriate.  The implementation might lean towards inappropriateness, but fundamentally there is nothing wrong here.\n\nThe usage you highlighted above uses a well-defined dbus object (Control.Power) that exposes a PGood property.  This is totally reasonable, since in many designs you cannot get a PGood signal from a GPIO directly.  There many designs that use some kind of communication to get the PGood state: IPMB, PLDM, custom CPLD protocol.",
      "parentUuid": "e309647e_5f4fe9a6",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec1f174e_7d500511",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-06-11T10:24:55Z",
      "side": 1,
      "message": "Okay, so bringing this back toward the problem I\u0027m grappling with...with PGood we have the Chassis.Control.Power interface that x86-power-control can use to retrieve the current state of the signal (and of course receive notifications when it changes).  The existing State.OperatingSystem.Status interface is *almost* small/simple enough to be analogous for POST_COMPLETE, but it\u0027s a string/enum property instead of a bool as x86-power-control would currently require, so it seems like we\u0027d either need to add yet another even more minimal special-purpose dbus interface or perhaps alternately build a slightly richer config mechanism into x86-power-control\u0027s dbus inputs to give them an optional string to compare against to map enums to bools, e.g. something like:\n\n```\n{\n  \"Name\": \"PostComplete\",\n  \"Type\": \"DBUS\",\n  \"DbusName\": \"...\",\n  \"Path\": \"...\",\n  \"Interface\": \"xyz.openbmc_project.State.OperatingSystem.Status\",\n  \"Property\": \"OperatingSystemState\",\n  \"MatchString\": \"xyz.openbmc_project.State.OperatingSystem.Status.OSStatus.Standby\"\n}\n```\n\nSo the signal would be considered `true` when the value of the property compares equal to `MatchString`.\n\n(x86-power-control also happens to provide the State.OperatingSystem.Status interface itself, but I guess we could have that basically just be a slightly roundabout replica of an \"upstream\" one optionally provided by ipmid?)",
      "parentUuid": "b6dedbba_22408205",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c4253b2_36bc70ae",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-06-11T16:22:52Z",
      "side": 1,
      "message": "üëç\n\nI\u0027d prefer the `MatchString` approach.\n\nYou do have to consider both IPMI and PLDM providing these values.",
      "parentUuid": "ec1f174e_7d500511",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "683a1a47_6247f2d6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-06-11T19:52:57Z",
      "side": 1,
      "message": "Yeah, that definitely seemed like the more appealing of the two to me.\n\nI guess then the next question that occurs to me is if it\u0027d be good to generalize it a bit more...in principle we\u0027d want some mechanism to convert a dbus property of arbitrary type into a bool, but building that in just for this (let alone devising a way of expressing it in JSON) seems like overkill.  I\u0027m thinking perhaps a regex match instead of a straight string-equality comparison might be a good compromise between simplicity of implementation and flexibility for potential future needs (e.g. matching any of multiple possible values of an enum instead of just one).\n\n\u003e You do have to consider both IPMI and PLDM providing these values.\n\nI\u0027m not sure I understand your intent here though -- are the particular constraints or behavioral aspects of one vs. the other that would need special accommodation here?",
      "parentUuid": "2c4253b2_36bc70ae",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85b1c051_f831a991",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000000
      },
      "writtenOn": "2024-06-11T20:00:13Z",
      "side": 1,
      "message": "\u003e\u003e You do have to consider both IPMI and PLDM providing these values.\n\n\u003e I\u0027m not sure I understand your intent here though -- are the particular constraints or behavioral aspects of one vs. the other that would need special accommodation here?\n\nOnly that you mentioned IPMI but PLDM is also a possible end-point.\n\nOverall I don\u0027t have a strong opinion on x86-power-control.  I\u0027m recommending all of the systems I work with use phosphor-state-manager at this point.  There are a few references of x86 systems using it.",
      "parentUuid": "683a1a47_6247f2d6",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c9681d3_3e8b5f55",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 12,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-06-11T20:37:01Z",
      "side": 1,
      "message": "\u003e Only that you mentioned IPMI but PLDM is also a possible end-point.\n\nAh, okay -- that was just an artifact of the fact that the system I\u0027m working on happens to receive the info via IPMI; I don\u0027t think it\u0027ll really factor into the implementation here.\n\n\u003e Overall I don\u0027t have a strong opinion on x86-power-control.\n\nAck.  Alright, I think I\u0027ll proceed with something like a `MatchRegex` config key as outlined above.",
      "parentUuid": "85b1c051_f831a991",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 18
      },
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "39d7579b_e12f4ea5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-05-07T02:27:34Z",
      "side": 1,
      "message": "CCing owners of the x86-power-control configs in openbmc/openbmc (yosemitev2 \u0026 rl300-g11) that utilize dbus signals...",
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a715eb9c_35fb56c8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000276
      },
      "writtenOn": "2024-05-10T21:07:15Z",
      "side": 1,
      "message": "Looks good to me.  I\u0027ll leave at +1 for a bit to give others a chance to provide feedback.",
      "revId": "af4a8da508ffc10fcda2fe9a610ddc8ec79078eb",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}