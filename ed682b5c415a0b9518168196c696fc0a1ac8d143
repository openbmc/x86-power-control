{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "710c951e_c1e453f3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000276
      },
      "writtenOn": "2024-02-26T18:27:12Z",
      "side": 1,
      "message": "Seems okay, but would still like to get Zev\u0027s feedback.",
      "revId": "ed682b5c415a0b9518168196c696fc0a1ac8d143",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5165fcfc_b3dcbd30",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-02-27T09:09:54Z",
      "side": 1,
      "message": "I\u0027m a bit confused about exactly what\u0027s now being done with the new line...\n\nDuring initialization in `main()` first we deassert it, and then later assert it just before entering the main event loop -- but both times it\u0027s then immediately reset?  (Explicitly at line 2910, and implicitly in the `hpmLine` dtor at line 3484.)  I\u0027m not clear on (a) what the deassert \u0026 reassert are actually needed for (i.e. what operations in between them actually *need* to be in between them, or why they\u0027re placed where they are), and (b) if they\u0027re actually going to reliably do anything other than just momentarily glitch the state of the line if there\u0027s a `.reset()` right after each one.  Am I misunderstanding something here?",
      "revId": "ed682b5c415a0b9518168196c696fc0a1ac8d143",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c35d1bdb_49005ba7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000086
      },
      "writtenOn": "2024-02-27T09:19:40Z",
      "side": 1,
      "message": "Zev,\nCan you please look/respond to https://gerrit.openbmc.org/c/openbmc/x86-power-control/+/48951/4..6/src/power_control.cpp#b2904 supreeth comments dated  on Feb 21.",
      "parentUuid": "5165fcfc_b3dcbd30",
      "revId": "ed682b5c415a0b9518168196c696fc0a1ac8d143",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3fd9869c_fe41c0ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-02-28T02:59:26Z",
      "side": 1,
      "message": "I\u0027m assuming you mean the comment starting \"Please note ...\"?  Due to time zone differences (I\u0027m guessing) that appears as Feb 20 for me, anyway (it sure would be nice if gerrit could link to a specific comment and not just an entire thread, but oh well...)\n\nAs for specific concerns, my main concern is just more a general lack of clarity about what\u0027s going on.  From Supreeth\u0027s description and the initial implementation, it seems like simply holding the line asserted and leaving it that way at all times (i.e. functionally equivalent to a gpio-hog as far as I can tell) is sufficient logic for the hardware you\u0027re working on to work, but then later the patch was changed to first deassert (at the same point in the initialization sequence where it had initially been asserted) and then later assert it (and again, both of those are immediately followed by resets, so it\u0027s even less clear what\u0027s actually happening).\n\nFrom Supreeth\u0027s description it sounds like this line being asserted is a signal that the BMC is ready to handle power events (i.e. a \"BMC ready\" signal but scoped only to power control, which if that\u0027s what it is does seem like a reasonable thing for x86-power-control to handle).  It seems like the only sensible way for that to work at a hardware level though would be to have a pull-up/down on the line to deassert it unless/until the BMC actively asserts it.  Is that the case?  (The reference to latching behavior in Supreeth\u0027s subsequent message is also confusing to me; I\u0027m not sure what to make of it.)\n\nWhat I\u0027d like is a clear explanation of:\n - what specifically the deassert/assert actions in the current patch are intended to achieve and why they\u0027re placed where they are, and\n - what the expected behavior is given that both of those actions are immediately followed by a reset of the line.",
      "parentUuid": "c35d1bdb_49005ba7",
      "revId": "ed682b5c415a0b9518168196c696fc0a1ac8d143",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16533556_ba676b6d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000086
      },
      "writtenOn": "2024-02-28T07:22:40Z",
      "side": 1,
      "message": "1. https://gerrit.openbmc.org/c/openbmc/x86-power-control/+/48951/6/src/power_control.cpp#2900 --\u003e Make sure when the power-control application starts , HpmStdby signal default state . deassert. This is based on earlier conversation with Jason and you. Yo make sure any application crash or reboot we need to hold the host power-control after the pre-steps completion, to avoid un-expected results due to HPM_STBY_EN ready state.\n\n2. https://gerrit.openbmc.org/c/openbmc/x86-power-control/+/48951/6/src/power_control.cpp#2910 -\u003e this is only reset C++ object. No real hardware actions  \n\n3. https://github.com/brgl/libgpiod/blob/6d5d8afc9c7e9a7b47d54fe51f4cb8d7077cdb8b/bindings/cxx/gpiodcxx/line-config.hpp#L58)\nhttps://gerrit.openbmc.org/c/openbmc/x86-power-control/+/48951/6/src/power_control.cpp#3474 -\u003e\nHPM_STBY_EN is one of the dedicated signals that will need to be controlled by power management/control module. , this signal will be set to indicate BMC\u0027s power control module is ready to take the inputs [PWR_GOOD] from the HPM FPGA after the app initialization completion. That is why we moved just before sd-event loop.",
      "parentUuid": "3fd9869c_fe41c0ba",
      "revId": "ed682b5c415a0b9518168196c696fc0a1ac8d143",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "475ff5db_ee5d5c1b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2024-02-28T08:38:45Z",
      "side": 1,
      "message": "Summarizing some out-of-band discussion with Jayanth:\n\n - The deassert during initialization seems oddly placed to me; it seems like (to minimize the amount of time the line might theoretically be incorrectly asserted) we\u0027d want to do that as early as possible, but currently it seems to have been inserted into the GPIO init sequence somewhat arbitrarily.  I\u0027d think it should probably be OK to move it earlier; any foreseeable problems with that?\n\n - The `line.reset()` operation (by closing open file descriptors) effectively releases the line and leaves its state undefined, which isn\u0027t great -- however, this is an existing problem with the codebase and not a new issue with this patch (numerous existing GPIOs are already kind of only working by luck in the same way, so what\u0027s one more...)\n\n@Jason, any thoughts on the deassert reordering or historical background on why the daemon releases output GPIOs instead of holding them open persistently while it\u0027s running?",
      "parentUuid": "16533556_ba676b6d",
      "revId": "ed682b5c415a0b9518168196c696fc0a1ac8d143",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}