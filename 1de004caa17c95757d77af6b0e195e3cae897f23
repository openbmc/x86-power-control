{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d5760bdb_5f873831",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-08-22T23:58:26Z",
      "side": 1,
      "message": "I\u0027m a bit confused about the hardware arrangement this is intended to handle.  On all the systems I\u0027m using x86-power-control on the power button is only connected to a BMC GPIO and isn\u0027t wired directly to anything else, so it\u0027s up to the BMC to handle it in software (or via an ast2500 GPIO passthrough configuration, but that\u0027s sort of tangential), and the existing code works fine.  What\u0027s different about the Tyan hardware that necessitates altering the logic in this daemon?",
      "revId": "1de004caa17c95757d77af6b0e195e3cae897f23",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1424bb28_fc2f2992",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2023-08-23T08:27:35Z",
      "side": 1,
      "message": "if i understand the code correctly, \ndifferent events happen and then getPowerStateHandler(...)\nreturns the event handler for that power state to handle it.\n\n\u0027powerStateOn(...)\u0027 is such a handler.\nInside that handler, if event is Event::powerButtonPressed\nit was the case that following code would be run:\n\nsetPowerState(PowerState::gracefulTransitionToOff);\ngracefulPowerOffTimerStart();\n\nwhich changes the power state (has no effect on any gpios or power control hw)\nand starts a timer (has no effect on any gpios or power control hw).\n\nNow the powerStateGracefulTransitionToOff\ncan receive Event::psPowerOKDeAssert event \nwhich can cancel that timer and transition to PowerState::off.\n\nIn my opinion, to explain the diff to the power control happening in case of dbus \nEvent::powerOffRequest, the \nassertGPIOForMs(powerOutConfig, TimerMap[\"ForceOffPulseMs\"])\nfrom forcePowerOff function has to happen in hardware.\n\nIf it were just a gpio without connection to power control logic, where is the power control happening? Which function is then causing the powerok gpio to change state? And why would the logic in that case be any different than a power on/off request from dbus?\n\nOn the specific Tyan S5549 Chassis that this patch is for, x86-power-control registers the button press but the expected change in powerok gpio does not happen without this patch.\n\nOn another Tyan S8030 the x86-power-control works without issue. In both cases the button press is registered.",
      "parentUuid": "d5760bdb_5f873831",
      "revId": "1de004caa17c95757d77af6b0e195e3cae897f23",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87ee2072_fad607a4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-08-24T00:27:33Z",
      "side": 1,
      "message": "Oh, sorry -- I had forgotten that my systems are in fact also dependent on the Aspeed GPIO passthrough feature for this, so it\u0027s not actually as tangential as I\u0027d thought.  Might that be an option for the S5549?",
      "parentUuid": "1424bb28_fc2f2992",
      "revId": "1de004caa17c95757d77af6b0e195e3cae897f23",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "684c9388_3767cab5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2023-08-24T11:58:14Z",
      "side": 1,
      "message": "yes, it might be. I can try it out, maybe this patch is not needed after all.\nDo you have any other examples than aspeed-bmc-inspur-nf5280m6.dts which can be shared? \n\nWhen applying it\u0027s configuration, it did not have the same effect as this patch. Maybe some mistake on my part. Some devicetree snippet would already help.",
      "parentUuid": "87ee2072_fad607a4",
      "revId": "1de004caa17c95757d77af6b0e195e3cae897f23",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f1b9a62_54d23b90",
        "filename": "src/power_control.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1730,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2023-08-24T00:27:33Z",
      "side": 1,
      "message": "Do we really want a single power button press to proceed directly to a forceful power cut?  I think on most systems it\u0027s treated more like `gracefulPowerOffRequest`, and to trigger a hard power-cut you press and hold the button for something like 6 seconds or so.",
      "range": {
        "startLine": 1729,
        "startChar": 0,
        "endLine": 1730,
        "endChar": 32
      },
      "revId": "1de004caa17c95757d77af6b0e195e3cae897f23",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ac6953b_2505a28c",
        "filename": "src/power_control.cpp",
        "patchSetId": 3
      },
      "lineNbr": 1730,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2023-08-24T11:58:14Z",
      "side": 1,
      "message": "Making it configurable would be nice. I would have to look to see if the implementation supports detecting button presses of configurable length.",
      "parentUuid": "1f1b9a62_54d23b90",
      "range": {
        "startLine": 1729,
        "startChar": 0,
        "endLine": 1730,
        "endChar": 32
      },
      "revId": "1de004caa17c95757d77af6b0e195e3cae897f23",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ],
  "submitRequirementResults": []
}